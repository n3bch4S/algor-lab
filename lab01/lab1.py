import timeimport matplotlib.pyplot as pltimport numpy as npclass Counter :    def __init__(self, count = 0) :        self.count = count            def counting(self, value = 1) :        self.count += value            def reset(self, count = 0) :        self.count = countdef isPrime(n, counter) : # 2(floor(sqrt(n)) - 1) + 9    counter.counting()    if type(n) is not int :        print("Type is not supported to check for prime")        return False    if n < 2 :        return False        target = int(n ** 0.5)    for i in range(2, target + 1) :        counter.counting()        if n % i == 0 :            return False    return Truedef myFactory(n, counter) :    counter.counting()    facNum = []    if type(n) is not int :        print("Type is not supported to factorize")        return facNum    if n < 0 :        print("Number can not be negative to factorize")        return facNum    if n < 2 :        return [n]        target = int(n ** 0.5)    primeSet = set()    for i in range(target + 1) :        counter.counting()        if isPrime(i, counter) :            primeSet.add(i)    for i in primeSet :        counter.counting()        if n % i == 0 :            while n % i == 0 :                counter.counting()                n = n // i                facNum.append(i)    if n != 1 :        facNum.append(n)    return facNumdef sieveFactory(n, counter) :    counter.counting()    facNum = []    if type(n) is not int :        print("Type is not supported to factorize")        return facNum    if n < 0 :        print("Number can not be negative to factorize")        return facNum    if n < 2 :        return [n]        target = int(n ** 0.5)    primeSet = set()    testField = [True for x in range(target + 1)]    for i in range(2, len(testField) - 1) :        counter.counting()        if not testField[i] :            continue        j = 2        while i * j <= target :            counter.counting()            testField[i * j] = False            j += 1    for i in range(2, len(testField)) :        counter.counting()        if testField[i] :            primeSet.add(i)        for i in primeSet :        counter.counting()        if n % i == 0 :            while n % i == 0 :                counter.counting()                n = n // i                facNum.append(i)    if n != 1 :        facNum.append(n)    return facNumdef isIntList(li, counter) :    counter.counting()    if type(li) is not list :        return False    for i in li :        counter.counting()        if type(i) is not int :            return False    return Truedef commonPair(liM, liN, counter) :    counter.counting()    pair = []    if not isIntList(liM, counter) or not isIntList(liN, counter) :        print("Some list is not int list, can not find common pair")        return pair        for i in liM :        counter.counting()        if i in liN :            liN.remove(i)            pair.append(i)    return pairdef capPi(li, counter) :    counter.counting()    product = 1    if not isIntList(li, counter) :        print("This list is not int list, can not calculate product")        return None        for i in li :        counter.counting()        product *= i    return productdef absolute(x, counter) :    counter.counting()    if not(type(x) is int or type(x) is float) :        print("This argument is not a number")        return None    return -1 * x if x < 0 else x'''def FindGCD1(m, n) :    if type(m) is not int or type(n) is not int :        print("Some argument is not int, can not find GCD")        return None    if m == 0 or n == 0 :        return 0    m = absolute(m)    n = absolute(n)        facM = myFactory(m)    facN = myFactory(n)    commonPrime = commonPair(facM, facN)    return capPi(commonPrime)'''def FindGCD1(arg, counter) :    counter.counting()    if not isIntList(arg, counter) :        print("Some argument is not int, can not find GCD")        return None    if 0 in arg :        return 0    if len(arg) == 1 :        return arg[0]    arg = [absolute(x, counter) for x in arg]        fac = [myFactory(x, counter) for x in arg]    while len(fac) > 1 :        counter.counting()        fac[0] = commonPair(fac[0], fac[-1], counter)        fac.pop()    return capPi(fac[0], counter)'''def FindGCD2(m, n) :    if type(m) is not int or type(n) is not int :        print("Some argument is not int, can not find GCD")        return None    if m == 0 or n == 0 :        return 0    m = absolute(m)    n = absolute(n)        facM = sieveFactory(m)    facN = sieveFactory(n)    commonPrime = commonPair(facM, facN)    return capPi(commonPrime)'''def FindGCD2(arg, counter) :    counter.counting()    if not isIntList(arg, counter) :        print("Some argument is not int, can not find GCD")        return None    if 0 in arg :        return 0    if len(arg) == 1 :        return arg[0]    arg = [absolute(x, counter) for x in arg]        fac = [sieveFactory(x, counter) for x in arg]    while len(fac) > 1 :        counter.counting()        fac[0] = commonPair(fac[0], fac[-1], counter)        fac.pop()    return capPi(fac[0], counter)'''def FindGCD3(m, n) :    if type(m) is not int or type(n) is not int :        print("Some argument is not int, can not find GCD")        return None    if m == 0 or n == 0 :        return 0    m = absolute(m)    n = absolute(n)    #print(f'm: {m}, n: {n}')        if m == n :        return m    elif m > n and m % n != 0 :        return FindGCD3(m % n, n)    elif m > n :        return n    elif n % m != 0 :        return FindGCD3(m, n % m)    else :        return m'''    def FindGCD3(arg, counter) :    counter.counting()    if not isIntList(arg, counter) :        print("Some argument is not int, can not find GCD")        return None    if 0 in arg :        return 0    if len(arg) == 1 :        return arg[0]    arg = [absolute(x, counter) for x in arg]        m = arg[0]    n = arg[-1]    if m == n :        arg.pop()        return arg    elif m > n and m % n != 0 :        arg[0] = m % n        return FindGCD3(arg, counter)    elif m > n :        arg.pop(0)        return FindGCD3(arg, counter)    elif n % m != 0 :        arg[-1] = n % m        return FindGCD3(arg, counter)    else :        arg.pop()        return FindGCD3(arg, counter)        def timer(func, arg) :    startTime = time.time()    retValue = func(arg)    endTime = time.time()    duration = endTime - startTime    return (retValue, duration)testcase = ('Case1.txt',            "Extra Case1.txt",            "Extra Case2 plotV2.txt")SELECT_CASE = 2START_DIGIT = 2MAX_DIGIT = 9file = open(testcase[SELECT_CASE], "r")naiveTime = []sieveTime = []euclidTime = []remaining = 0for line in file :    lineSplit = line.split(",")    if len(lineSplit[0]) > MAX_DIGIT :        continue    i = [int(x) for x in lineSplit]    naiveCounter = Counter()    sieveCounter = Counter()    euclidCounter = Counter()    naiveResult = FindGCD1(i, naiveCounter)    sieveResult = FindGCD2(i, sieveCounter)    euclidResult = FindGCD3(i, euclidCounter)        if remaining <= 0 :        naiveTime.append([])        sieveTime.append([])        euclidTime.append([])        remaining = 5    naiveTime[-1].append(naiveCounter.count)    sieveTime[-1].append(sieveCounter.count)    euclidTime[-1].append(euclidCounter.count)    remaining -= 1    print(f'{i}\n' +          '------\n' +          f'{naiveResult} ({naiveCounter.count} operations)\n' +          f'{sieveResult} ({sieveCounter.count} operations)\n' +          f'{euclidResult} ({euclidCounter.count} operations)\n\n')file.close()avgNaiveTime = np.array([sum(x) / len(x) for x in naiveTime])avgSieveTime = np.array([sum(x) / len(x) for x in sieveTime])avgEuclidTime = np.array([sum(x) / len(x) for x in euclidTime])digitNum = np.array([x + START_DIGIT for x in range(len(naiveTime))])plt.plot(digitNum, avgNaiveTime, label = "Naive")plt.plot(digitNum, avgSieveTime, label = "Sieve")plt.plot(digitNum, avgEuclidTime, label = "Euclid")plt.xlabel("Digit number")plt.ylabel("Average Operations")plt.legend()plt.show()